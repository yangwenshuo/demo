package com.shipeiqimoshi;

public class Client {

	public static void main(String[] args) {



		// TODO Auto-generated method stub
		//应用场景:
		//想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。
		
		//翻译者模式无非就是外面搞个包装类,把成员变量对象的方法包装下,有点像装饰者.
		
		//这个案例是 吕布去了外国打仗,听不懂英文,不知道何时进攻何时撤退,给他搞了个翻译
		
		
		//代理模式是不会改变被代理对象的接口的,被代理对象有什么接口他就有什么接口,
		//因为代理对象和被代理对象都是实现了同一个接口,所以动态代理创建对象时要获取
		//被代理对象的接口啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊
		//而适配器模式就可以改变被适配对象的接口,他俩也不是实现了同一个接口,他就是
		//对一些不符合接口的类进行改造的,咋能跟你一样,你接口和现在规范不匹配了.
		//我用适配器改造你
		//而装饰者模式其实和代理模式差不多也是继承了同一个接口,但是装饰者模式强调
		//的是对接口方法的增强,而代理模式强调的是对你的访问的对象加上一层访问控制
		//......但是我们的动态代理好像就是增强..........
		
		Transfer t = new Transfer(new LvBu());
		t.attack("attack");
		t.fallBack("fallback");
				
	}

}
