package com.dailimoshi;

public class Client {
	//代理模式:为其他对象提供一种代理以控制堆这个对象的访问
	public static void main(String[] args){
		
/*		动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器
		一个集中的方法中处理（InvocationHandler.invoke）。
		这样，在接口方法数量比较多的时候，
		我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
		而且动态代理的应用使我们的类职责更加单一，复用性更强*/
		
		
		
		
		//可见,在前面的装饰者模式和代理模式,都是同样的接口的实现类,然后一个对象的内部的一个成员变量是另一个类的对象 ,
		//那么我们就可以在这个类中对方法就行操作.
		
		//代理模式可以把被代理对象隐藏了,比如此例中,,秘书心情好的时候就通知老板,如果心情不好就不告诉老板,你无法访问到老板.
		
		//代理可以有多个,
		//代理与委托实现类实现了同一个接口,那么这两个就会有一些相同的方法.
		//在委托类种是实现功能,在代理类中引用委托类的同名方法.
		//外部类调用委托的某个方法时,就会指向内部的方法
		
		//可以隐藏一个类的某些功能,并对一些功能进行扩展
		
		//为其他对象提供一种代理以控制对这个对象的访问
		//增加了代理对象和逻辑,可能会降低速度
		
		//代理模式是不会改变被代理对象的接口的,被代理对象有什么接口他就有什么接口,
		//因为代理对象和被代理对象都是实现了同一个接口,所以动态代理创建对象时要获取
		//被代理对象的接口啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊
		//而适配器模式就可以改变被适配对象的接口,他俩也不是实现了同一个接口,他就是
		//对一些不符合接口的类进行改造的,咋能跟你一样,你接口和现在规范不匹配了.
		//我用适配器改造你
		//而装饰者模式其实和代理模式差不多也是继承了同一个接口,但是装饰者模式强调
		//的是对接口方法的增强,而代理模式强调的是对你的访问的对象加上一层访问控制
		//......但是我们的动态代理好像就是增强..........
		
		MiShu ms = new MiShu();
		Boss b = new Boss();
		ms.setP(b);
		
		ms.meet();
		
	}
}
