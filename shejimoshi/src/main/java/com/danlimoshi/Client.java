package com.danlimoshi;
	
public class Client {

	//单例模式面试经常问到还可能让你手写代码!!!
	
	
	//单例模式主要是保证无论在那里,还是多线程下都是只创建一个对象
	
	//单例模式注意要把里对象的构造方法私有.
	//单例模式注意要把里对象的构造方法私有.
	//单例模式注意要把里对象的构造方法私有.
	//单例模式注意要把里对象的构造方法私有.
	//单例模式注意要把里对象的构造方法私有.
	//单例模式注意要把里对象的构造方法私有.
	
	

	
	
	
	//单例模式主要是私有构造和提供静态的getInstance方法.
	
	
	
	
	
	
	
	
	
	
	
	
	
	//单例模式:保证一个类仅有一个实例对象,并提供一个他的安全的全局访问.
	
	//单例模式的场景:比如计数器对象,我们只搞一个计数器对象,搞多了不行,我们可以搞一个计数工具类,这个类中搞一个获取计数器对象的方法,
	//但是从这个方法里获取的对象都是同一个.
	//或者一个工具类C3P0Utils,他要使用一些连接池变量对象,对于一个程序来说,连接池肯定只有一个.
	
	//为了我们方便的获取到单例对象,我们通常把无论是计数器对象还是连接池对象放在工具类的静态成员变量里面,
	//这样就可以用工具类名直接获取到单例对象.
	
	//上面我们说了单例对象通常都放在工具类的静态成员变量里,这就产生了两种形式的单例模式,
	//第一种 饿汉模式:直接在静态里面就new出里对象,这样的话就是只要类一加载,那么这个单例对象就创建了,然后我们提供一个
	//get对象的方法返回这个对象就可以.
	//第二种 懒汉模式:在工具类的静态单例对象先初始化成null,然后再提供的get对象的方法里,进行操作
	//如果工具类的静态单例对象是null,说明这是第一个访问,那么创建这个单例对象,然后返回,后面的访问那么工具类的静态单例对象
	//肯定就不是null了.
	//这两种的区别就是第一个是类加载的时候就创建,随静态内容的创建而创建,第二个是当调用get对象的时候创建,都是创建一次.
	
	//饿汉模式比较简单.
	//懒汉模式主要在创建的时候有双重否定的概念:
	//	getWife(){
	//		if(this.wife == null){   为什么要搞两次判断,要注意,第一次多线程不搞两个可能有问题.
				//第一次很多线程都是null,所以会同时跑到这里,但是只有一个获得到了锁.
	//			synchronized(obj){
				//获得锁的那个线程进来后发现是还是null,就创建了这个对象,然后退出,后面的进来,如果这里没有这个非空判断的话
				//后面的线程还以后这里对象是null呢,其实第一个进来的线程已经创建对象了.
	//				if(this.wife == null){
	//					this.wife = new Wife();
	//				}
	//			}
	//		}else{
	//			return
	//		}
	//	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Wife w = Wife.getInstance();
		Wife w1 = Wife.getInstance();
		System.out.println(w);
		System.out.println(w1);
	}

}
